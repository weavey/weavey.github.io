<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[直接拿去用！几种常见Dialog2.0]]></title>
      <url>%2F2016%2F12%2F28%2F%E7%9B%B4%E6%8E%A5%E6%8B%BF%E5%8E%BB%E7%94%A8%E4%B9%8BDialog2%2F</url>
      <content type="text"><![CDATA[前言前面封装了项目中经常使用到的几种Dialog，自己在使用过程中也发现了一些问题，使用不是很方便，决定改动个别方法，故升到2.0。 引用方式gradle引用compile &apos;com.lai.weavey:dialog:2.0.1&apos; Maven配置&lt;dependency&gt; &lt;groupId&gt;com.lai.weavey&lt;/groupId&gt; &lt;artifactId&gt;dialog&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;/dependency&gt; GitHub项目地址https://github.com/weavey/NormalSelectDialog,欢迎fork或star，提出宝贵意见，有其他常用的Dialog可以告知，有时间将一起封装进本库。 2.0改动Dialog的属性设置与1.3版本基本无差别，改动了点击事件的接口回调,统一管理并公用,将Dialog对象返回： public interface DialogInterface { interface OnLeftAndRightClickListener&lt;T&gt; { void clickLeftButton(T dialog, View view); void clickRightButton(T dialog, View view); } interface OnSingleClickListener&lt;T&gt; { void clickSingleButton(T dialog, View view); } interface OnItemClickListener&lt;T&gt; { void onItemClick(T dialog, View button, int position); } } 使用方法样式一：NormalSelectionDialog 使用如下代码： ArrayList&lt;String&gt; s = new ArrayList&lt;&gt;(); s.add(&quot;Weavey0&quot;); s.add(&quot;Weavey1&quot;); s.add(&quot;Weavey2&quot;); s.add(&quot;Weavey3&quot;); new NormalSelectionDialog.Builder(this).setlTitleVisible(true) //设置是否显示标题 .setTitleHeight(65) //设置标题高度 .setTitleText(&quot;please select&quot;) //设置标题提示文本 .setTitleTextSize(14) //设置标题字体大小 sp .setTitleTextColor(R.color.colorPrimary) //设置标题文本颜色 .setItemHeight(40) //设置item的高度 .setItemWidth(0.9f) //屏幕宽度*0.9 .setItemTextColor(R.color.colorPrimaryDark) //设置item字体颜色 .setItemTextSize(14) //设置item字体大小 .setCancleButtonText(&quot;Cancle&quot;) //设置最底部“取消”按钮文本 .setOnItemListener(new DialogInterface.OnItemClickListener&lt;NormalSelectionDialog&gt;() { @Override public void onItemClick(NormalSelectionDialog dialog, View button, int position) { dialog.dismiss(); } }) .setCanceledOnTouchOutside(true) //设置是否可点击其他地方取消dialog .build() .setDatas(s) .show(); 样式二：NormalAlertDialog 使用如下代码： new NormalAlertDialog.Builder(MainActivity.this).setTitleVisible(false) .setTitleText(&quot;温馨提示&quot;) .setTitleTextColor(R.color.black_light) .setContentText(&quot;是否关闭对话框？&quot;) .setContentTextColor(R.color.black_light) .setLeftButtonText(&quot;关闭&quot;) .setLeftButtonTextColor(R.color.gray) .setRightButtonText(&quot;不关闭&quot;) .setRightButtonTextColor(R.color.black_light) .setOnclickListener(new DialogInterface.OnLeftAndRightClickListener&lt;NormalAlertDialog&gt;() { @Override public void clickLeftButton(NormalAlertDialog dialog, View view) { dialog.dismiss(); } @Override public void clickRightButton(NormalAlertDialog dialog, View view) { dialog.dismiss(); } }) .build() .show(); 样式三：NormalAlertDialog（单键） 使用如下代码： new NormalAlertDialog.Builder(MainActivity.this).setHeight(0.23f) //屏幕高度*0.23 .setWidth(0.65f) //屏幕宽度*0.65 .setTitleVisible(true).setTitleText(&quot;温馨提示&quot;) .setTitleTextColor(R.color.colorPrimary) .setContentText(&quot;是否关闭对话框？&quot;) .setContentTextColor(R.color.colorPrimaryDark) .setSingleMode(true).setSingleButtonText(&quot;关闭&quot;) .setSingleButtonTextColor(R.color.colorAccent) .setCanceledOnTouchOutside(true) .setSingleListener(new DialogInterface.OnSingleClickListener&lt;NormalAlertDialog&gt;() { @Override public void clickSingleButton(NormalAlertDialog dialog, View view) { dialog.dismiss(); } }) .build() .show(); 样式四：MDAlertDialog 使用如下代码： new MDAlertDialog.Builder(MainActivity.this) .setHeight(0.21f) //屏幕高度*0.21 .setWidth(0.7f) //屏幕宽度*0.7 .setTitleVisible(true) .setTitleText(&quot;温馨提示&quot;) .setTitleTextColor(R.color.black_light) .setContentText(&quot;确定发送文件？&quot;) .setContentTextColor(R.color.black_light) .setLeftButtonText(&quot;不发送&quot;) .setLeftButtonTextColor(R.color.gray) .setRightButtonText(&quot;发送&quot;) .setRightButtonTextColor(R.color.black_light) .setTitleTextSize(16) .setContentTextSize(14) .setButtonTextSize(14) .setOnclickListener(new DialogInterface.OnLeftAndRightClickListener&lt;MDAlertDialog&gt;() { @Override public void clickLeftButton(MDAlertDialog dialog, View view) { dialog.dismiss(); } @Override public void clickRightButton(MDAlertDialog dialog, View view) { dialog.dismiss(); } }) .build() .show(); 样式五：MDSelectionDialog 使用如下代码： datas = new ArrayList&lt;&gt;(); datas.add(&quot;标为未读&quot;); datas.add(&quot;置顶聊天&quot;); datas.add(&quot;删除该聊天&quot;); new MDSelectionDialog.Builder(MainActivity.this) .setCanceledOnTouchOutside(true) .setItemTextColor(R.color.black_light) .setItemHeight(50) .setItemWidth(0.8f) //屏幕宽度*0.8 .setItemTextSize(15) .setCanceledOnTouchOutside(true) .setOnItemListener(new DialogInterface.OnItemClickListener&lt;MDSelectionDialog&gt;() { @Override public void onItemClick(MDSelectionDialog dialog, View button, int position) { dialog.dismiss(); } }) .build() .setDatas(datas) .show(); 样式六：MDEditDialog 使用如下代码： new MDEditDialog.Builder(MainActivity.this).setTitleVisible(true) .setTitleText(&quot;修改用户名&quot;) .setTitleTextSize(20) .setTitleTextColor(R.color.black_light) .setContentText(&quot;Weavey&quot;) .setContentTextSize(18) .setMaxLength(7) .setHintText(&quot;7位字符&quot;) .setMaxLines(1) .setContentTextColor(R.color.colorPrimary) .setButtonTextSize(14) .setLeftButtonTextColor(R.color.colorPrimary) .setLeftButtonText(&quot;取消&quot;) .setRightButtonTextColor(R.color.colorPrimary) .setRightButtonText(&quot;确定&quot;) .setLineColor(R.color.colorPrimary) .setInputTpye(InputType.TYPE_CLASS_NUMBER) .setOnclickListener(new DialogInterface.OnLeftAndRightClickListener&lt;MDEditDialog&gt; () { @Override public void clickLeftButton(MDEditDialog dialog, View view) { dialog.getEditTextContent(); dialog.dismiss(); } @Override public void clickRightButton(MDEditDialog dialog, View view) { dialog.getEditTextContent(); dialog.dismiss(); } }) .setMinHeight(0.3f) .setWidth(0.8f) .build() .show();]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[直接拿去用！每个App都会用到的LoadingLayout]]></title>
      <url>%2F2016%2F11%2F28%2F%E7%9B%B4%E6%8E%A5%E6%8B%BF%E5%8E%BB%E7%94%A8%E4%B9%8BLoadingLayout%2F</url>
      <content type="text"><![CDATA[前言项目里都会遇到几种页面，分别为加载中、无网络、无数据、出错四种情况，经常要使用，所以封成库引用了，方便使用，顺便分享出来。先看一下效果： 原理比较简单，继承FrameLayout，在xml渲染完成后，加上加载中、无网络、无数据、出错四个页面，根据需要控制显示哪一层，花了些时间，开了很多方法出来，支持很多属性的设置，算是比较实用，源码里已对各个方法的作用都加了注释，就不做过多解释了，项目GitHub地址：https://github.com/weavey/LoadingLayoutDemo，感兴趣的可以看看，欢迎指出问题。 使用方式gradle引用： compile ‘com.lai.weavey:loadinglayout:1.3.1’ 使用说明 LoadingLayout支持全局配置，对所有使用到的地方都起效，需要在Application中配置，如下： public class App extends Application { @Override public void onCreate() { super.onCreate(); LoadingLayout.getConfig() .setErrorText(&quot;出错啦~请稍后重试！&quot;) .setEmptyText(&quot;抱歉，暂无数据&quot;) .setNoNetworkText(&quot;无网络连接，请检查您的网络···&quot;) .setErrorImage(R.mipmap.define_error) .setEmptyImage(R.mipmap.define_empty) .setNoNetworkImage(R.mipmap.define_nonetwork) .setAllTipTextColor(R.color.gray) .setAllTipTextSize(14) .setReloadButtonText(&quot;点我重试哦&quot;) .setReloadButtonTextSize(14) .setReloadButtonTextColor(R.color.gray) .setReloadButtonWidthAndHeight(150,40); } } 由于“加载中”的页面，可能每个App都不一样，因此，LoadingLayout支持自定义LoadingPage，如下： LoadingLayout.getConfig().setLoadingPageLayout(R.layout.define_loading_page); 同时，为了适应个别界面的“特殊需求”，LoadingLayout也支持局部设置各种属性，仅对当前对象生效，不影响全局。如下： LoadingLayout loading = (LoadingLayout) findViewById(R.id.loading_layout); loading.setLoadingPage(R.layout.define_loading_page) .setEmptyText(&quot;暂无报告数据&quot;) .setErrorText(&quot;&quot;) .setNoNetworkText(&quot;&quot;) .setErrorImage(R.mipmap.ic_launcher) .setErrorTextSize(16) .setReloadButtonText(&quot;点我重新加载哦&quot;); //等等 为ReloadButton设置监听: loadingLayout.setOnReloadListener(new LoadingLayout.OnReloadListener() { @Override public void onReload(View v) { } }); 设置显示的页面： loadingLayout.setStatus(LoadingLayout.Loading);//加载中 loadingLayout.setStatus(LoadingLayout.Empty);//无数据 loadingLayout.setStatus(LoadingLayout.Error);//错误 loadingLayout.setStatus(LoadingLayout.No_Network);//无网络 loadingLayout.setStatus(LoadingLayout.Success);//加载成功 最后，在xml里面使用： &lt;com.weavey.loading.lib.LoadingLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:paddingBottom=&quot;@dimen/activity_vertical_margin&quot; android:paddingLeft=&quot;@dimen/activity_horizontal_margin&quot; android:paddingRight=&quot;@dimen/activity_horizontal_margin&quot; android:paddingTop=&quot;@dimen/activity_vertical_margin&quot; app:isFirstVisible=&quot;true&quot;&gt; &lt;TextView android:background=&quot;@color/colorPrimary&quot; android:visibility=&quot;visible&quot; android:gravity=&quot;center&quot; android:textColor=&quot;@android:color/white&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:text=&quot;ContentView&quot;/&gt; &lt;/com.weavey.loading.lib.LoadingLayout&gt; 注意： （1）isFirstVisible属性用来控制contentView一开始是否隐藏，由于LoadingLayout原理是在xml渲染完成后在contentView上铺上三层View，因此，一开始如果不隐藏，等contentView渲染完成后调用: loadingLayout.setStatus(LoadingLayout.Loading);会造成界面闪烁的效果，影响体验，因此默认将contentView隐藏，所以数据加载完成后一定要调用loadingLayout.setStatus(LoadingLayout.Success);，将contentView显示出来。这样也能解决未获取到数据的情况下，被用户看到杂乱无章的布局，个人还是比较喜欢默认隐藏contentView； （2）为了方便管理，LoadingLayout只能有一个直属子View，类似ScrollView，添加两个直属子View会抛出异常throw new IllegalStateException(&quot;LoadingLayout can host only one direct child&quot;);； （3）由于AS会直接将自定义View的特性反应在预览界面，所以在使用LoadingLayout的时候，会无法看到被LoadingLayout包裹住的布局（默认为gone），因此也可以将isFirstVisible属性暂时设为true，预览布局。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[我所理解的RxJava——上手其实很简单（三）]]></title>
      <url>%2F2016%2F11%2F03%2F%E6%88%91%E6%89%80%E7%90%86%E8%A7%A3RxJava3%2F</url>
      <content type="text"><![CDATA[前言最近诸事缠身，有点忙，终于抽出时间&amp;&amp;有兴致写第三了，有一股深深的罪恶感，废话不多说，还是直接接上篇的活了，讲一讲一些比较常用的操作符吧。然后这篇讲RxJava中强大的Scheduler调度器 ，就是因为它，RxJava才能极其简便的在线程中切换，接着再讲一讲一些常用的操作符，比较简单容易理解的操作符都在本篇罗列出来，以后可能不定时更新这篇文章，复杂的操作符后续分篇讲。 Scheduler在讲常用操作符前，先看看Scheduler这个东西，名之为调度器，正因为有这个东西，让RxJava可以从主线程和子线程之间轻松切换，各个Scheduler的具体使用效果看以下解释： Schedulers.computation( ) 用于计算任务，如事件循环或和回调处理，不要用于IO操作(IO操作请使用Schedulers.io())；默认线程数等于处理器的数量; Schedulers.from(executor) 使用指定的Executor作为调度器; Schedulers.immediate( ) 在当前线程立即开始执行任务; Schedulers.io( ) 用于IO密集型任务，如异步阻塞IO操作，这个调度器的线程池会根据需要增长；对于普通的计算任务，请使用Schedulers.computation()；Schedulers.io( )默认是一个CachedThreadScheduler，很像一个有线程缓存的新线程调度器; Schedulers.newThread( ) 为每个任务创建一个新线程; Schedulers.trampoline( ) 当其它排队的任务完成后，在当前线程排队开始执行; AndroidSchedulers.mainThread() 此调度器为RxAndroid特有，顾名思义，运行在Android UI线程上。 具体如何使用呢，比如从数据库读取数据更新到UI上，假设数据量很大，直接从主线程读取数据，会造成UI卡顿，以前我们常用AnsyTask或者Handler去处理避免出现这类问题，个人认为手写个AnsyTask还是挺麻烦的，但用RxJava就简单多了，例如： Observable.create(new Observable.OnSubscribe&lt;Data&gt;() { @Override public void call(Subscriber&lt;? super Data&gt; subscriber) { Data data = getData();//从数据库获取 subscriber.onNext(data); subscriber.onCompleted(); }}) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;Data&gt;() { @Override public void call(Data data) { //更新ui } }); 简单粗暴的解释一下，subscribeOn( )决定了发射数据在哪个调度器上执行，observeOn(AndroidSchedulers.mainThread())则指定数据接收发生在UI线程，简直不要太方便。 常用操作符Map 最常用且最实用的操作符之一，将对象转换成另一个对象发射出去，应用范围非常广，如数据的转换，数据的预处理等。 例一：数据类型转换，改变最终的接收的数据类型。假设传入本地图片路径，根据路径获取图片的Bitmap。 Observable.just(filePath).map(new Func1&lt;String, Bitmap&gt;() { @Override public Bitmap call(String path) { return getBitmapByPath(path); }}).subscribe(new Action1&lt;Bitmap&gt;() { @Override public void call(Bitmap bitmap) { //获取到bitmap，显示 }}); 例二：对数据进行预处理，最后得到理想型数据。实际开发过程中，从后台接口获取到的数据也许不符合我们想要的，这时候可以在获取过程中对得到的数据进行预处理（结合Retrofit）。 Observable.just(&quot;12345678&quot;).map(new Func1&lt;String, String&gt;() { @Override public String call(String s) { return s.substring(0,4);//只要前四位 }}) .subscribe(new Action1&lt;String&gt;() { @Override public void call(String s) { Log.i(&quot;mytag&quot;,s); }}); 先说明一下，为了方便理解，所以写的例子都比较简单，不要以为明明可以简单用if-else解决的事，没必要用这种方式去写，当你真正将这些操作符使用到数据处理中去的时候，你就会发现有多方便。 FlatMap 和Map很像但又有所区别，Map只是转换发射的数据类型，而FlatMap可以将原始Observable转换成另一个Observable。还是举例说明吧。假设要打印全国所有学校的名称，可以直接用Map,为了更清晰一点，先贴一下School类： public class School { private String name; private List&lt;Student&gt; studentList; public List&lt;Student&gt; getStudentList() { return studentList; } public void setStudentList(List&lt;Student&gt; studentList) { this.studentList = studentList; } public String getName() { return name; } public void setName(String name) { this.name = name; } public static class Student{ private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } } } 接着用Map打印学校名称： List&lt;School&gt; schoolList = new ArrayList&lt;&gt;(); Observable.from(schoolList).map(new Func1&lt;School, String&gt;() { @Override public String call(School school) { return school.getName(); }}).subscribe(new Action1&lt;String&gt;() { @Override public void call(String schoolName) { Log.i(&quot;mytag&quot;,schoolName); }}); 再进一步，打印学校所有学生的姓名，先考虑用Map实现，将所有School对象直接转成Student： Observable.from(schoolList).map(new Func1&lt;School, School.Student&gt;() { @Override public School.Student call(School school) { return school.getStudentList(); }}).subscribe(new Action1&lt;School.Student&gt;() { @Override public void call(School.Student student) { Log.i(&quot;mytag&quot;,student.getName()); }}); 看似可行，但事实上，这是一段错误的代码，细心的人就会发现错误的地方 @Override public School.Student call(School school) { return school.getStudentList(); //错误，Student 是一个对象，返回的却是一个list } 所以用Map是无法实现直接打印学校的所有学生名字的，因为Map是一对一的关系，无法将单一的School对象转变成多个Student。前面说到，FlatMap可以改变原始Observable变成另外一个Observable，如果我们能利用from()操作符把school.getStudentList()变成另外一个Observable问题不就迎刃而解了吗，这时候就该FlatMap上场了，来看看它是怎么实现的： Observable.from(schoolList).flatMap(new Func1&lt;School, Observable&lt;School.Student&gt;&gt;() { @Override public Observable&lt;School.Student&gt; call(School school) { return Observable.from(school.getStudentList()); //关键，将学生列表以另外一个Observable发射出去 }}).subscribe(new Action1&lt;School.Student&gt;() { @Override public void call(School.Student student) { Log.i(&quot;mytag&quot;,student.getName()); }}); Map和FlatMap在我看来就像孪生兄弟一样，非常实用，实际开发中也我也经常使用，个人觉得要想上手RxJava，掌握这两个操作符必不可少。 Buffer 缓存，可以设置缓存大小，缓存满后，以list的方式将数据发送出去,例： Observable.just(1,2,3).buffer(2).subscribe(new Action1&lt;List&lt;Integer&gt;&gt;() { @Override public void call(List&lt;Integer&gt; list) { Log.i(&quot;mytag&quot;,&quot;size:&quot;+list.size()); }}); 运行打印结果如下： 11-02 20:49:58.370 23392-23392/? I/mytag: size:2 11-02 20:49:58.370 23392-23392/? I/mytag: size:1 在开发当中，个人经常将Buffer和Map一起使用，常发生在从后台取完数据，对一个List中的数据进行预处理后，再用Buffer缓存后一起发送，保证最后数据接收还是一个List，如下： List&lt;School&gt; schoolList = new ArrayList&lt;&gt;(); Observable.from(schoolList).map(new Func1&lt;School, School&gt;() { @Override public School call(School school) { school.setName(&quot;NB大学&quot;); //将所有学校改名 return school; }}).buffer(schoolList.size()) //缓存起来，最后一起发送 .subscribe(new Action1&lt;List&lt;School&gt;&gt;() { @Override public void call(List&lt;School&gt; schools) { }}); Take 发射前n项数据，还是用上面的例子，假设不要改所有学校的名称了，就改前四个学校的名称： Observable.from(schoolList).take(4).map(new Func1&lt;School, School&gt;() { @Override public School call(School school) { school.setName(&quot;NB大学&quot;); return school; }}).buffer(4).subscribe(new Action1&lt;List&lt;School&gt;&gt;() { @Override public void call(List&lt;School&gt; schools) { }}); Distinct 去掉重复的项，比较好理解： Observable.just(1, 2, 1, 1, 2, 3) .distinct() .subscribe(new Action1&lt;Integer&gt;() { @Override public void call(Integer item) { System.out.println(&quot;Next: &quot; + item); } }); 输出 Next: 1 Next: 2 Next: 3 Filter 过滤，通过谓词判断的项才会被发射，例如，发射小于4的数据： Observable.just(1, 2, 3, 4, 5).filter(new Func1&lt;Integer, Boolean&gt;() { @Override public Boolean call(Integer item) { return( item &lt; 4 ); } }).subscribe(new Action1&lt;Integer&gt;() { @Override public void call(Integer item) { System.out.println(&quot;Next: &quot; + item); }}); 输出： Next: 1 Next: 2 Next: 3 这一篇就先讲这么多吧，重点掌握Map和FlatMap操作符，因为真的很实用、很实用、很实用，重要的事讲三遍。 后语其实，讲真，到现在RxJava已经非常普遍，用的人很多，网上的干货也很多，写这几篇文章呢，除了帮助想开始学RxJava的新手入门，最重要的还是起到一个笔记的作用吧，好记性不如烂笔头，这是真的。好吧，这篇就写这么多了，欢迎指出问题，互相交流学习。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[直接拿去用！几种常见Dialog，懒人必收]]></title>
      <url>%2F2016%2F09%2F07%2F%E7%9B%B4%E6%8E%A5%E6%8B%BF%E5%8E%BB%E7%94%A8%E4%B9%8BDialog%2F</url>
      <content type="text"><![CDATA[前言项目中经常使用到的几种Dialog，所以干脆封装起来了，方便以后使用，顺便分享给大家，话不多说，直接看效果。 引用方式gradle引用compile &apos;com.lai.weavey:dialog:1.3&apos; Maven配置&lt;dependency&gt; &lt;groupId&gt;com.lai.weavey&lt;/groupId&gt; &lt;artifactId&gt;dialog&lt;/artifactId&gt; &lt;version&gt;1.1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;/dependency&gt; GitHub项目地址,欢迎fork或star，提出宝贵意见https://github.com/weavey/NormalSelectDialog 使用方法样式一：NormalSelectionDialog 使用如下代码： NormalSelectionDialog dialog1 = new NormalSelectionDialog.Builder(this) .setlTitleVisible(true) //设置是否显示标题 .setTitleHeight(65) //设置标题高度 .setTitleText(&quot;please select&quot;) //设置标题提示文本 .setTitleTextSize(14) //设置标题字体大小 sp .setTitleTextColor(R.color.colorPrimary) //设置标题文本颜色 .setItemHeight(40) //设置item的高度 .setItemWidth(0.9f) //屏幕宽度*0.9 .setItemTextColor(R.color.colorPrimaryDark) //设置item字体颜色 .setItemTextSize(14) //设置item字体大小 .setCancleButtonText(&quot;Cancle&quot;) //设置最底部“取消”按钮文本 .setOnItemListener(new DialogOnItemClickListener() { //监听item点击事件 @Override public void onItemClick(Button button, int position) { // dialog1.dismiss(); Toast.makeText(MainActivity.this, s.get(position), Toast.LENGTH_SHORT).show(); } }) .setCanceledOnTouchOutside(true) //设置是否可点击其他地方取消dialog .build(); ArrayList&lt;String&gt; s = new ArrayList&lt;&gt;(); s.add(&quot;Weavey0&quot;); s.add(&quot;Weavey1&quot;); s.add(&quot;Weavey2&quot;); s.add(&quot;Weavey3&quot;); dialog1.setDataList(s); 样式二：NormalAlertDialog 使用如下代码： NormalAlertDialog dialog2 = new NormalAlertDialog.Builder(MainActivity.this) .setHeight(0.23f) //屏幕高度*0.23 .setWidth(0.65f) //屏幕宽度*0.65 .setTitleVisible(true) .setTitleText(&quot;温馨提示&quot;) .setTitleTextColor(R.color.black_light) .setContentText(&quot;是否关闭对话框？&quot;) .setContentTextColor(R.color.black_light) .setLeftButtonText(&quot;关闭&quot;) .setLeftButtonTextColor(R.color.gray) .setRightButtonText(&quot;不关闭&quot;) .setRightButtonTextColor(R.color.black_light) .setOnclickListener(new DialogOnClickListener() { @Override public void clickLeftButton(View view) { // dialog2.dismiss(); } @Override public void clickRightButton(View view) { // dialog2.dismiss(); } }) .build(); 样式三：NormalAlertDialog 使用如下代码： NormalAlertDialog dialog3 = new NormalAlertDialog.Builder(MainActivity.this) .setHeight(0.23f) //屏幕高度*0.23 .setWidth(0.65f) //屏幕宽度*0.65 .setTitleVisible(true) .setTitleText(&quot;温馨提示&quot;) .setTitleTextColor(R.color.colorPrimary) .setContentText(&quot;是否关闭对话框？&quot;) .setContentTextColor(R.color.colorPrimaryDark) .setSingleMode(true) .setSingleButtonText(&quot;关闭&quot;) .setSingleButtonTextColor(R.color.colorAccent) .setCanceledOnTouchOutside(true) .setSingleListener(new View.OnClickListener() { @Override public void onClick(View view) { // dialog3.dismiss(); } }) .build(); 样式四：MDAlertDialog 使用如下代码： MDAlertDialog dialog4 = new MDAlertDialog.Builder(MainActivity.this) .setHeight(0.21f) //屏幕高度*0.21 .setWidth(0.7f) //屏幕宽度*0.7 .setTitleVisible(true) .setTitleText(&quot;温馨提示&quot;) .setTitleTextColor(R.color.black_light) .setContentText(&quot;确定发送文件？&quot;) .setContentTextColor(R.color.black_light) .setLeftButtonText(&quot;不发送&quot;) .setLeftButtonTextColor(R.color.gray) .setRightButtonText(&quot;发送&quot;) .setRightButtonTextColor(R.color.black_light) .setTitleTextSize(16) .setContentTextSize(14) .setButtonTextSize(14) .setOnclickListener(new DialogOnClickListener() { @Override public void clickLeftButton(View view) { // dialog4.dismiss(); } @Override public void clickRightButton(View view) { // dialog4.dismiss(); } }) .build(); 样式五：MDSelectionDialog 使用如下代码： MDSelectionDialog dialog5 = new MDSelectionDialog.Builder(MainActivity.this) .setCanceledOnTouchOutside(true) .setItemTextColor(R.color.black_light) .setItemHeight(50) .setItemWidth(0.8f) //屏幕宽度*0.8 .setItemTextSize(15) .setCanceledOnTouchOutside(true) .setOnItemListener(new DialogOnItemClickListener() { @Override public void onItemClick(Button button, int position) { Toast.makeText(MainActivity.this, datas.get(position), Toast.LENGTH_SHORT).show(); // dialog5.dismiss(); } }) .build(); datas = new ArrayList&lt;&gt;(); datas.add(&quot;标为未读&quot;); datas.add(&quot;置顶聊天&quot;); datas.add(&quot;删除该聊天&quot;); dialog5.setDataList(datas); 样式六：MDEditDialog 使用如下代码： MDEditDialog dialog6 = new MDEditDialog.Builder(MainActivity.this) .setTitleVisible(true) .setTitleText(&quot;修改用户名&quot;) .setTitleTextSize(20) .setTitleTextColor(R.color.black_light) .setContentText(&quot;Weavey&quot;) .setContentTextSize(18) .setMaxLength(7) .setHintText(&quot;7位字符&quot;) .setMaxLines(1) .setContentTextColor(R.color.colorPrimary) .setButtonTextSize(14) .setLeftButtonTextColor(R.color.colorPrimary) .setLeftButtonText(&quot;取消&quot;) .setRightButtonTextColor(R.color.colorPrimary) .setRightButtonText(&quot;确定&quot;) .setLineColor(R.color.colorPrimary) .setOnclickListener(new MDEditDialog.OnClickEditDialogListener() { @Override public void clickLeftButton(View view, String text) { //text为编辑的内容 } @Override public void clickRightButton(View view, String text) { //text为编辑的内容 } }) .setMinHeight(0.3f) .setWidth(0.8f) .build();]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[我所理解的RxJava——上手其实很简单（二）]]></title>
      <url>%2F2016%2F08%2F31%2F%E6%88%91%E6%89%80%E7%90%86%E8%A7%A3RxJava2%2F</url>
      <content type="text"><![CDATA[Subject关于Subject，官方文档的解释是这样的：Subject可以看成是一个桥梁或者代理，在某些ReactiveX实现中（如RxJava），它同时充当了Observer和Observable的角色。因为它是一个Observer，它可以订阅一个或多个Observable；又因为它是一个Observable，它可以转发它收到(Observe)的数据，也可以发射新的数据。从官方解释中，我提取出三个要点： 它可以充当Observable； 它可以充当Observer； 它是Observable和Observer之间的桥梁； 接下来对这三个要点解释一下，但在解释之前，要先介绍一下Subject的种类， Subject是一个抽象类，不能通过new来实例化Subject，所以Subject有四个实现类，分别为AsyncSubject、BehaviorSubject、PublishSubject和ReplaySubject，每个实现类都有特定的“技能”，下面结合代码来介绍一下它们各自的“技能”。注意，所有的实现类都由create()方法实例化，无需new,所有的实现类调用onCompleted()或onError(),它的Observer将不再接收数据； Subject的分类解析AsyncSubjectObserver会接收AsyncSubject的onComplete()之前的最后一个数据，如果因异常而终止,AsyncSubject将不会释放任何数据，但是会向Observer传递一个异常通知。示例代码如下： AsyncSubject&lt;String&gt; asyncSubject = AsyncSubject.create(); asyncSubject.onNext(&quot;asyncSubject1&quot;); asyncSubject.onNext(&quot;asyncSubject2&quot;); asyncSubject.onNext(&quot;asyncSubject3&quot;); asyncSubject.onCompleted(); asyncSubject.subscribe(new Observer&lt;String&gt;() { @Override public void onCompleted() { LogUtil.log(&quot;asyncSubject onCompleted&quot;); //输出 asyncSubject onCompleted } @Override public void onError(Throwable e) { LogUtil.log(&quot;asyncSubject onError&quot;); //不输出（异常才会输出） } @Override public void onNext(String s) { LogUtil.log(&quot;asyncSubject:&quot;+s); //输出asyncSubject:asyncSubject3 } }); 以上代码，Observer只会接收asyncSubject的onCompleted()被调用前的最后一个数据，即asyncSubject3，如果不调用onCompleted()，Subscriber将不接收任何数据。 BehaviorSubjectObserver会接收到BehaviorSubject被订阅之前的最后一个数据，再接收其他发射过来的数据，如果BehaviorSubject被订阅之前没有发送任何数据，则会发送一个默认数据。（注意跟AsyncSubject的区别，AsyncSubject要手动调用onCompleted()，且它的Observer会接收到onCompleted()前发送的最后一个数据，之后不会再接收数据，而BehaviorSubject不需手动调用onCompleted()，它的Observer接收的是BehaviorSubject被订阅前发送的最后一个数据，两个的分界点不一样，且之后还会继续接收数据。）示例代码如下： BehaviorSubject&lt;String&gt; behaviorSubject = BehaviorSubject.create(&quot;default&quot;); behaviorSubject.onNext(&quot;behaviorSubject1&quot;); behaviorSubject.onNext(&quot;behaviorSubject2&quot;); behaviorSubject.subscribe(new Observer&lt;String&gt;() { @Override public void onCompleted() { LogUtil.log(&quot;behaviorSubject:complete&quot;); } @Override public void onError(Throwable e) { LogUtil.log(&quot;behaviorSubject:error&quot;); } @Override public void onNext(String s) { LogUtil.log(&quot;behaviorSubject:&quot;+s); } }); behaviorSubject.onNext(&quot;behaviorSubject3&quot;); behaviorSubject.onNext(&quot;behaviorSubject4&quot;); 以上代码，Observer会接收到behaviorSubject2、behaviorSubject3、behaviorSubject4，如果在behaviorSubject.subscribe()之前不发送behaviorSubject1、behaviorSubject2，则Observer会先接收到default,再接收behaviorSubject3、behaviorSubject4。 PublishSubjectPublishSubject比较容易理解，相对比其他Subject常用，它的Observer只会接收到PublishSubject被订阅之后发送的数据。示例代码如下： PublishSubject&lt;String&gt; publishSubject = PublishSubject.create(); publishSubject.onNext(&quot;publishSubject1&quot;); publishSubject.onNext(&quot;publishSubject2&quot;); publishSubject.subscribe(new Observer&lt;String&gt;() { @Override public void onCompleted() { } @Override public void onError(Throwable e) { } @Override public void onNext(String s) { LogUtil.log(&quot;publishSubject observer1:&quot;+s); } }); publishSubject.onNext(&quot;publishSubject3&quot;); publishSubject.onNext(&quot;publishSubject4&quot;); 以上代码，Observer只会接收到”behaviorSubject3“、”behaviorSubject4“。 ReplaySubjectReplaySubject会发射所有数据给观察者，无论它们是何时订阅的。也有其它版本的ReplaySubject，在重放缓存增长到一定大小的时候或过了一段时间后会丢弃旧的数据。示例代码如下： ReplaySubject&lt;String&gt;replaySubject = ReplaySubject.create(); //创建默认初始缓存容量大小为16的ReplaySubject，当数据条目超过16会重新分配内存空间，使用这种方式，不论ReplaySubject何时被订阅，Observer都能接收到数据 //replaySubject = ReplaySubject.create(100);//创建指定初始缓存容量大小为100的ReplaySubject //replaySubject = ReplaySubject.createWithSize(2);//只缓存订阅前最后发送的2条数据 //replaySubject=ReplaySubject.createWithTime(1,TimeUnit.SECONDS,Schedulers.computation()); //replaySubject被订阅前的前1秒内发送的数据才能被接收 replaySubject.onNext(&quot;replaySubject:pre1&quot;); replaySubject.onNext(&quot;replaySubject:pre2&quot;); replaySubject.onNext(&quot;replaySubject:pre3&quot;); replaySubject.subscribe(new Action1&lt;String&gt;() { @Override public void call(String s) { LogUtil.log(&quot;replaySubject:&quot; + s); } }); replaySubject.onNext(&quot;replaySubject:after1&quot;); replaySubject.onNext(&quot;replaySubject:after2&quot;); 以上代码，由于情况比较多，注释也已解释的相当清楚，就不对输出结果一一表述了，有疑问的自行copy代码去测试一下。至此，四种Subject类型已经介绍完毕，但是需要注意，如果你把 Subject 当作一个 Subscriber使用，不要从多个线程中调用它的onNext方法（包括其它的on系列方法），这可能导致同时（非顺序）调用，这会违反Observable协议，给Subject的结果增加了不确定性。要避免此类问题，官方提出了“串行化”，你可以将 Subject 转换为一个 SerializedSubject ，类似于这样： SerializedSubject&lt;String, Integer&gt; ser = new SerializedSubject(publishSubject); 要点解答接下来，我们继续前面提出的问题，为什么说Subject既可充当Observable，又可充当Observer，是它们两个之间的桥梁呢？ 经过前面的例子，也许有些人已经大概理解了，不理解的且听我细细道来。首先，从理论上讲，Subject继承了Observable，又实现了Observer接口，所以说它既是Observable又是Observer，完全合理。从实际应用上讲，Subject也能实现Observable和Observer相同的功能，口说无凭，我们还是通过代码来证实比较有说服力。创建Observable并发射数据： Observable.create(new Observable.OnSubscribe&lt;String&gt;() { @Override public void call(Subscriber&lt;? super String&gt; subscriber) { subscriber.onNext(&quot;I&apos;m Observable&quot;); subscriber.onCompleted(); } }); 用Subject实现为： PublishSubject&lt;String&gt; publishSubject = PublishSubject.create(); publishSubject.onNext(&quot;as Observable&quot;); publishSubject.onCompleted(); 创建Observer订阅Observable并接收数据： mObservable.subscribe(new Observer&lt;String&gt;() { @Override public void onCompleted() { } @Override public void onError(Throwable e) { } @Override public void onNext(String s) { //接收数据 } }); 用Subject实现为： publishSubject.subscribe(new Observer&lt;String&gt;() { @Override public void onCompleted() { } @Override public void onError(Throwable e) { } @Override public void onNext(String s) { } }); 也许有人会问，不是说Subject也可以作为Observer，不能把Subject当作Observer传入subscribe()中吗？回答是：当然可以！就象这样： PublishSubject&lt;String&gt; publishSubject = PublishSubject.create(); Observable.create(new Observable.OnSubscribe&lt;String&gt;() { @Override public void call(Subscriber&lt;? super String&gt; subscriber) { subscriber.onNext(&quot;as Observer&quot;); subscriber.onCompleted(); } }).subscribe(publishSubject); 有没有发现问题？publishSubject没有重写onNext()方法啊，在哪接收的数据？这就是前面说的“桥梁”的问题了，尽管把Subject作为Observer传入subscribe()，但接收数据还是要通过Observer来接收，借用Subject来连接Observable和Observer，整体代码如下： PublishSubject&lt;String&gt; publishSubject = PublishSubject.create(); Observable.create(new Observable.OnSubscribe&lt;String&gt;() { @Override public void call(Subscriber&lt;? super String&gt; subscriber) { subscriber.onNext(&quot;as Bridge&quot;); subscriber.onCompleted(); } }).subscribe(publishSubject); publishSubject.subscribe(new Observer&lt;String&gt;() { @Override public void onCompleted() { } @Override public void onError(Throwable e) { } @Override public void onNext(String s) { LogUtil.log(&quot;subject:&quot;+s); //接收到 as Bridge } }); 没错，这很桥梁！ 总结关于Subject，到此就介绍完了。也许你会跟我一样困惑，为什么又要多个Subject出来，除了有几个特定功能之外，其他所有的一切，Observable和Observer也都有，而且写法上也没有原来的简便。确实如此，对于几个特定功能，我也还想不到有什么应用场景，至少我还没发现有什么场景必须得用Subject来实现不可，那么问题又来了，我为什么要花这么大篇幅来介绍Subject，理由有三。其一，既然官方推出Subject，必有其道理，还没遇到不代表以后不会遇到，更不能代表你不会遇到这样的应用场景；其二，“一千个读者有一千个哈姆雷特”，我所看到的并不是全部，也许你会发掘出更有意思的东西可不是？其三，我可不想当你看完我所有关于RxJava的文章，自信已上手RxJava，当有人跟你提起Subject的时候，你一脸茫然不知道Subject是什么东西，岂不哀哉？所以呢，介绍一下Subject还是很有意义的，最起码学了比没学好，“养兵千日用兵一时”，知识不嫌多，突然哪天就用上了呢。对于Subject的理解，有异议的欢迎底下评论，一起交流进步。下一篇文章，进入RxJava操作符的使用讲解。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[我所理解的RxJava——上手其实很简单（一）]]></title>
      <url>%2F2016%2F08%2F27%2F%E6%88%91%E6%89%80%E7%90%86%E8%A7%A3%E7%9A%84RxJava1%2F</url>
      <content type="text"><![CDATA[前言相信各位看官对RxJava早有耳闻，那么关于什么是RxJava我就不再赘述了，不知道的可自行百度。如果你已经大致了解过什么是RxJava，想开始学习，那么本文不失为你良好的选择，为什么这么说呢，因为我也是刚学几天，正所谓“知己知彼，百战不殆”。网上流传，RxJava的入门门槛高，而经过我这几天的学习，我反而不那么认为，精通我不敢说，但入门确实也不难，不信？我先来个简单的例子预热一下。 先创建个数据发射源,很好理解，就是发射数据用的： Observable&lt;String&gt; sender = Observable.create(new Observable.OnSubscribe&lt;String&gt;() { @Override public void call(Subscriber&lt;? super String&gt; subscriber) { subscriber.onNext(&quot;Hi，Weavey！&quot;); //发送数据&quot;Hi，Weavey！&quot; } }); 再创建个数据接收源，同理，接收数据用的： Observer&lt;String&gt; receiver = new Observer&lt;String&gt;() { @Override public void onCompleted() { //数据接收完成时调用 } @Override public void onError(Throwable e) { //发生错误调用 } @Override public void onNext(String s) { //正常接收数据调用 System.out.print(s); //将接收到来自sender的问候&quot;Hi，Weavey！&quot; } }; 好了，将发射源和接收源关联起来： sender.subscribe(receiver); 这样就形成RxJava一个简单的用法，sender发射&quot;Hi，Weavey！&quot;，将会被receiver的onNext的接收，通过这个例子，也许你会想到“异步”、“观察者模式”，没错，这些都是RxJava所做的事情，并且让他们变得更简单和简洁，而RxJava所有的一切都将围绕这两个点展开，一个是发射数据，一个是接收数据，是不是很通俗易懂？如果你理解了这点或者你已经知道RxJava就是这么一回事，那么恭喜你，你已经一只脚跨进RxJava的大门了，如果不是！！！！那也无所谓，请继续往下看… 论概念的重要性网上关于RxJava的博文也有很多，我也看过许多，其中不乏有优秀的文章，但绝大部分文章都有一个共同点，就是侧重于讲RxJava中各种强大的操作符，而忽略了最基本的东西——概念，所以一开始我也看的一脸懵逼，看到后面又忘了前面的，脑子里全是问号，这个是什么，那个又是什么，这两个长得怎么那么像。举个不太恰当的例子，概念之于初学者，就像食物之于人，当你饿了，你会想吃面包、牛奶，那你为什么不去吃土呢，因为你知道面包牛奶是用来干嘛的，土是用来干嘛的。同理，前面已经说过，RxJava无非是发送数据与接收数据，那么什么是发射源，什么是接收源，这就是你应该明确的事，也是RxJava的入门条件之一，下面就依我个人理解，对发射源和接收源做个归类，以及RxJava中频繁出现的几个“单词”解释一通，说的不好还请海涵，欢迎补充。 基本概念Observable 发射源，英文释义“可观察的”，在观察者模式中称为“被观察者”或“可观察对象”； Observer 接收源，英文释义“观察者”，没错！就是观察者模式中的“观察者”，可接收Observable、Subject发射的数据； Subject Subject是一个比较特殊的对象，既可充当发射源，也可充当接收源，为避免初学者被混淆，本章将不对Subject做过多的解释和使用，重点放在Observable和Observer上，先把最基本方法的使用学会，后面再学其他的都不是什么问题； Subscriber “订阅者”，也是接收源，那它跟Observer有什么区别呢？Subscriber实现了Observer接口，比Observer多了一个最重要的方法unsubscribe( )，用来取消订阅，当你不再想接收数据了，可以调用unsubscribe( )方法停止接收，Observer 在 subscribe() 过程中,最终也会被转换成 Subscriber 对象，一般情况下，建议使用Subscriber作为接收源； Subscription Observable调用subscribe( )方法返回的对象，同样有unsubscribe( )方法，可以用来取消订阅事件； Action0 RxJava中的一个接口，它只有一个无参call（）方法，且无返回值，同样还有Action1，Action2…Action9等，Action1封装了含有 1 个参的call（）方法，即call（T t），Action2封装了含有 2 个参数的call方法，即call（T1 t1，T2 t2），以此类推； Func0 与Action0非常相似，也有call（）方法，但是它是有返回值的，同样也有Func0、Func1…Func9; 基本用法Observable的创建create 使用create( ),最基本的创建方式： normalObservable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() { @Override public void call(Subscriber&lt;? super String&gt; subscriber) { subscriber.onNext(&quot;create1&quot;); //发射一个&quot;create1&quot;的String subscriber.onNext(&quot;create2&quot;); //发射一个&quot;create2&quot;的String subscriber.onCompleted();//发射完成,这种方法需要手动调用onCompleted，才会回调Observer的onCompleted方法 }}); just 使用just( )，将为你创建一个Observable并自动为你调用onNext( )发射数据： justObservable = Observable.just(&quot;just1&quot;,&quot;just2&quot;);//依次发送&quot;just1&quot;和&quot;just2&quot; from 使用from( )，遍历集合，发送每个item： List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;from1&quot;); list.add(&quot;from2&quot;); list.add(&quot;from3&quot;); fromObservable = Observable.from(list); //遍历list 每次发送一个 /** 注意，just()方法也可以传list，但是发送的是整个list对象，而from（）发送的是list的一个item** / defer 使用defer( )，有观察者订阅时才创建Observable，并且为每个观察者创建一个新的Observable： deferObservable = Observable.defer(new Func0&lt;Observable&lt;String&gt;&gt;() { @Override //注意此处的call方法没有Subscriber参数 public Observable&lt;String&gt; call() { return Observable.just(&quot;deferObservable&quot;); }}); intervalintervalObservable = Observable.interval(1, TimeUnit.SECONDS);//每隔一秒发送一次 range 使用range( ),创建一个发射特定整数序列的Observable，第一个参数为起始值，第二个为发送的个数，如果为0则不发送，负数则抛异常： rangeObservable = Observable.range(10, 5);//将发送整数10，11，12，13，14 timer 使用timer( ),创建一个Observable，它在一个给定的延迟后发射一个特殊的值，等同于Android中Handler的postDelay( )方法： timeObservable = Observable.timer(3, TimeUnit.SECONDS); //3秒后发射一个值 repeat 使用repeat( ),创建一个重复发射特定数据的Observable: repeatObservable = Observable.just(&quot;repeatObservable&quot;).repeat(3);//重复发射3次 Observer的创建mObserver = new Observer&lt;String&gt;() { @Override public void onCompleted() { LogUtil.log(&quot;onCompleted&quot;); } @Override public void onError(Throwable e) { } @Override public void onNext(String s) { LogUtil.log(s); }}; ok，有了Observable和Obsever，我们就可以随便玩了，任取一个已创建的Observable和Observer关联上，即形成一个RxJava的例子，如： justObservable.subscribe(mObserver); mObserver的onNext方法将会依次收到来自justObservable的数据&quot;just1&quot;、&quot;just2&quot;，另外，如果你不在意数据是否接收完或者是否出现错误，即不需要Observer的onCompleted()和onError()方法，可使用Action1，subscribe()支持将Action1作为参数传入,RxJava将会调用它的call方法来接收数据，代码如下： justObservable.subscribe(new Action1&lt;String&gt;() { @Override public void call(String s) { LogUtil.log(s); }}); 以上就是RxJava最简单的用法。看到这里，我也不知道我写的是否简单明了，也许你会想，“哎呀，写个异步的东西，怎么这么麻烦，为什么不用Thread+Handler呢”,那你就错了，RxJava也以代码的简洁深受广大用户喜爱，简洁不能理解为代码量少，而是随着逻辑的复杂，需求的更改，代码可依然能保持极强的阅读性，举个简单的例子（前方高能预警~~~），领导要我从数据库的用户表查找出所有用户数据，我二话不说拿出心仪的RxJava就写： Observable.create(new Observable.OnSubscribe&lt;List&lt;User&gt;&gt;() { @Override public void call(Subscriber&lt;? super List&lt;User&gt;&gt; subscriber) { List&lt;User&gt; userList = null; ··· //从数据库获取用户表数据并赋给userList ··· subscriber.onNext(userList); } }).subscribe(new Action1&lt;List&lt;User&gt;&gt;() { @Override public void call(List&lt;User&gt; users) { //获取到用户信息列表 } }); 但是，领导突然又不想要所有用户了，只要名字叫“小明”的用户，行吧，领导最大，我改（假设名字唯一）： Observable.create(new Observable.OnSubscribe&lt;List&lt;User&gt;&gt;() { @Override public void call(Subscriber&lt;? super List&lt;User&gt;&gt; subscriber) { List&lt;User&gt; userList = null; ··· //从数据库获取用户表数据并赋给userList ··· subscriber.onNext(userList); } }).flatMap(new Func1&lt;List&lt;User&gt;, Observable&lt;User&gt;&gt;() { @Override public Observable&lt;User&gt; call(List&lt;User&gt; users) { return Observable.from(users); } }).filter(new Func1&lt;User, Boolean&gt;() { @Override public Boolean call(User user) { return user.getName().equals(&quot;小明&quot;); } }).subscribe(new Action1&lt;User&gt;() { @Override public void call(User user) { //拿到谜之小明的数据 } }); 搞定，这时候领导又说，我不要小明了，我要小明的爸爸的数据，（坑爹啊~~），我继续改： Observable.create(new Observable.OnSubscribe&lt;List&lt;User&gt;&gt;() { @Override public void call(Subscriber&lt;? super List&lt;User&gt;&gt; subscriber) { List&lt;User&gt; userList = null; ··· //从数据库获取用户表数据并赋给userList ··· subscriber.onNext(userList); } }).flatMap(new Func1&lt;List&lt;User&gt;, Observable&lt;User&gt;&gt;() { @Override public Observable&lt;User&gt; call(List&lt;User&gt; users) { return Observable.from(users); } }).filter(new Func1&lt;User, Boolean&gt;() { @Override public Boolean call(User user) { return user.getName().equals(&quot;小明&quot;); } }).map(new Func1&lt;User, User&gt;() { @Override public User call(User user) { //根据小明的数据user从数据库查找出小明的父亲user2 return user2; } }).subscribe(new Action1&lt;User&gt;() { @Override public void call(User user2) { //拿到谜之小明的爸爸的数据 } }); 搞定，“还想怎么改？领导请说···”。以上例子，涉及到几个操作符，初学者可能无法理解，但是无所谓，这不是重点，我的目的只是为了向你展示RxJava在需求不断变更、逻辑愈加复杂的情况下，依旧可以保持代码简洁、可阅读性强的一面，没有各种回调，也没有谜之缩进！ 总结看了以上所讲，如果你已经爱上了RxJava，如果你已经全部理解，我确信，你已经跨入RxJava的大门，剩下的只是时间的问题以及如何在实际开发场景中去应用的问题，那么下篇文章，我将继续讲解RxJava中各种强大的操作符，并尽量以实际开发过程中遇到的问题作为例子，提升自己的同时，帮助初学者迅速上手RxJava，如有写的不好的地方，还请见谅，真心欢迎各路大神指点，探讨相关技术。]]></content>
    </entry>

    
  
  
</search>
